// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type AddressFilterInput struct {
	Eq  *string             `json:"eq,omitempty"`
	Ne  *string             `json:"ne,omitempty"`
	In  []*string           `json:"in,omitempty"`
	Nin []*string           `json:"nin,omitempty"`
	And []*ConvenientFilter `json:"and,omitempty"`
	Or  []*ConvenientFilter `json:"or,omitempty"`
}

type BooleanFilterInput struct {
	Eq  *bool               `json:"eq,omitempty"`
	Ne  *bool               `json:"ne,omitempty"`
	And []*ConvenientFilter `json:"and,omitempty"`
	Or  []*ConvenientFilter `json:"or,omitempty"`
}

type ConvenientFilter struct {
	Destination *AddressFilterInput `json:"destination,omitempty"`
	Executed    *BooleanFilterInput `json:"executed,omitempty"`
	And         []*ConvenientFilter `json:"and,omitempty"`
	Or          []*ConvenientFilter `json:"or,omitempty"`
}

type DelegateCallVoucher struct {
	// Voucher index within the context of the input that produced it
	Index int `json:"index"`
	// Input whose processing produced the voucher
	Input *Input `json:"input"`
	// Transaction destination address in Ethereum hex binary format (20 bytes), starting with '0x'
	Destination string `json:"destination"`
	// Transaction payload in Ethereum hex binary format, starting with '0x'
	Payload string `json:"payload"`
	// Proof object that allows this voucher to be validated and executed on the base layer blockchain
	Proof *Proof `json:"proof,omitempty"`
	// Indicates whether the voucher has been executed on the base layer blockchain
	Executed *bool `json:"executed,omitempty"`
	// The hash of executed transaction
	TransactionHash *string `json:"transactionHash,omitempty"`
}

// Pagination result
type DelegateCallVoucherConnection struct {
	// Total number of entries that match the query
	TotalCount int `json:"totalCount"`
	// Pagination entries returned for the current page
	Edges []*DelegateCallVoucherEdge `json:"edges"`
	// Pagination metadata
	PageInfo *PageInfo `json:"pageInfo"`
}

type DelegateCallVoucherEdge struct {
	// Node instance
	Node *DelegateCallVoucher `json:"node"`
	// Pagination cursor
	Cursor string `json:"cursor"`
}

// Filter object to restrict results depending on input properties
type InputFilter struct {
	// Filter only inputs with index lower than a given value
	IndexLowerThan *int `json:"indexLowerThan,omitempty"`
	// Filter only inputs with index greater than a given value
	IndexGreaterThan *int `json:"indexGreaterThan,omitempty"`
	// Filter only inputs with the message sender
	MsgSender *string `json:"msgSender,omitempty"`
	// Filter only inputs from 'inputbox' or 'espresso'
	Type *string `json:"type,omitempty"`
}

// Page metadata for the cursor-based Connection pagination pattern
type PageInfo struct {
	// Cursor pointing to the first entry of the page
	StartCursor *string `json:"startCursor,omitempty"`
	// Cursor pointing to the last entry of the page
	EndCursor *string `json:"endCursor,omitempty"`
	// Indicates if there are additional entries after the end curs
	HasNextPage bool `json:"hasNextPage"`
	// Indicates if there are additional entries before the start curs
	HasPreviousPage bool `json:"hasPreviousPage"`
}

type CompletionStatus string

const (
	CompletionStatusUnprocessed                CompletionStatus = "UNPROCESSED"
	CompletionStatusAccepted                   CompletionStatus = "ACCEPTED"
	CompletionStatusRejected                   CompletionStatus = "REJECTED"
	CompletionStatusException                  CompletionStatus = "EXCEPTION"
	CompletionStatusMachineHalted              CompletionStatus = "MACHINE_HALTED"
	CompletionStatusCycleLimitExceeded         CompletionStatus = "CYCLE_LIMIT_EXCEEDED"
	CompletionStatusTimeLimitExceeded          CompletionStatus = "TIME_LIMIT_EXCEEDED"
	CompletionStatusPayloadLengthLimitExceeded CompletionStatus = "PAYLOAD_LENGTH_LIMIT_EXCEEDED"
)

var AllCompletionStatus = []CompletionStatus{
	CompletionStatusUnprocessed,
	CompletionStatusAccepted,
	CompletionStatusRejected,
	CompletionStatusException,
	CompletionStatusMachineHalted,
	CompletionStatusCycleLimitExceeded,
	CompletionStatusTimeLimitExceeded,
	CompletionStatusPayloadLengthLimitExceeded,
}

func (e CompletionStatus) IsValid() bool {
	switch e {
	case CompletionStatusUnprocessed, CompletionStatusAccepted, CompletionStatusRejected, CompletionStatusException, CompletionStatusMachineHalted, CompletionStatusCycleLimitExceeded, CompletionStatusTimeLimitExceeded, CompletionStatusPayloadLengthLimitExceeded:
		return true
	}
	return false
}

func (e CompletionStatus) String() string {
	return string(e)
}

func (e *CompletionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CompletionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CompletionStatus", str)
	}
	return nil
}

func (e CompletionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
